<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Reactivity | Observable Framework</title>
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&amp;display=swap" crossorigin>
<link rel="preload" as="style" href="./_import/style.94d47c6c.css">
<link rel="preload" as="style" href="./_observablehq/stdlib/inputs.css">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css2?family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&amp;display=swap" crossorigin>
<link rel="stylesheet" type="text/css" href="./_import/style.94d47c6c.css">
<link rel="stylesheet" type="text/css" href="./_observablehq/stdlib/inputs.css">
<link rel="modulepreload" href="./_observablehq/client.js">
<link rel="modulepreload" href="./_observablehq/runtime.js">
<link rel="modulepreload" href="./_observablehq/stdlib.js">
<link rel="modulepreload" href="./_npm/htl@0.3.1/_esm.js">
<link rel="modulepreload" href="./_observablehq/stdlib/inputs.js">
<link rel="modulepreload" href="./_npm/@observablehq/plot@0.6.15/_esm.js">
<link rel="modulepreload" href="./_npm/isoformat@0.2.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3@7.9.0/_esm.js">
<link rel="modulepreload" href="./_npm/interval-tree-1d@1.0.4/_esm.js">
<link rel="modulepreload" href="./_npm/d3-array@3.2.4/_esm.js">
<link rel="modulepreload" href="./_npm/d3-axis@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-brush@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-chord@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-color@3.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-contour@4.0.2/_esm.js">
<link rel="modulepreload" href="./_npm/d3-delaunay@6.0.4/_esm.js">
<link rel="modulepreload" href="./_npm/d3-dispatch@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-drag@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-dsv@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-ease@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-fetch@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-force@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-format@3.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-geo@3.1.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-hierarchy@3.1.2/_esm.js">
<link rel="modulepreload" href="./_npm/d3-interpolate@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-path@3.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-polygon@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-quadtree@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-random@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-scale@4.0.2/_esm.js">
<link rel="modulepreload" href="./_npm/d3-scale-chromatic@3.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-selection@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-shape@3.2.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-time@3.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-time-format@4.1.0/_esm.js">
<link rel="modulepreload" href="./_npm/d3-timer@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-transition@3.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/d3-zoom@3.0.0/_esm.js">
<link rel="modulepreload" href="./_npm/binary-search-bounds@2.0.5/_esm.js">
<link rel="modulepreload" href="./_npm/internmap@2.0.3/_esm.js">
<link rel="modulepreload" href="./_npm/delaunator@5.0.1/_esm.js">
<link rel="modulepreload" href="./_npm/robust-predicates@3.0.2/_esm.js">
<link rel="apple-touch-icon" href="./_file/observable.1af93621.png">
<link rel="icon" type="image/png" href="./_file/observable.1af93621.png" sizes="32x32">
<script type="module">/Win/.test(navigator.platform) || Array.from(document.querySelectorAll(".win"), (e) => e.remove())</script>
<script type="module">

import {define} from "./_observablehq/client.js";
import {registerFile} from "./_observablehq/stdlib.js";

registerFile("./volcano.json", {"name":"./volcano.json","mimeType":"application/json","path":"./_file/volcano.f5223ec9.json","lastModified":1719665284059});

define({id: "bd100eeb", inputs: ["x","y","display"], body: async (x,y,display) => {
display(await(
x + y
))
}});

define({id: "724b726b", outputs: ["x","y"], body: () => {
const x = 1, y = 2;
return {x,y};
}});

define({id: "2d711642", mode: "inline", inputs: ["x","display"], body: async (x,display) => {
display(await(
x
))
}});

define({id: "a1fce436", mode: "inline", inputs: ["y","display"], body: async (y,display) => {
display(await(
y
))
}});

define({id: "5ac3981e", body: () => {
{
  const z = 3;
}
}});

define({id: "8a489158", inputs: ["FileAttachment"], outputs: ["volcano"], body: (FileAttachment) => {
const volcano = FileAttachment("./volcano.json").json();
return {volcano};
}});

define({id: "d1a89d65", inputs: ["volcano","display"], body: async (volcano,display) => {
display(await(
volcano
))
}});

define({id: "4b333a16", mode: "inline", inputs: ["volcano","display"], body: async (volcano,display) => {
display(await(
volcano.values.length.toLocaleString("en-US")
))
}});

define({id: "6a8a2621", outputs: ["fast","slow"], body: () => {
const fast = new Promise((resolve) => setTimeout(() => resolve("fast"), 500));
const slow = new Promise((resolve) => setTimeout(() => resolve("slow"), 5000));
return {fast,slow};
}});

define({id: "6c194ecc", inputs: ["display","fast","slow"], body: (display,fast,slow) => {
display(fast);
display(slow);
}});

define({id: "c233565e", outputs: ["one","two"], body: async () => {
const one = 1;
const two = 2;
await new Promise((resolve) => setTimeout(resolve, 5000));
return {one,two};
}});

define({id: "74aff20d", inputs: ["one","two","display"], body: async (one,two,display) => {
display(await(
one + two // waits 5 seconds!
))
}});

define({id: "42cc9a81", inputs: ["Generators","nameInput"], outputs: ["name"], body: (Generators,nameInput) => {
const name = Generators.input(nameInput);
return {name};
}});

define({id: "f80b1fa8", inputs: ["name","display"], body: async (name,display) => {
display(await(
name
))
}});

define({id: "b9872a62", mode: "inline", inputs: ["name","display"], body: async (name,display) => {
display(await(
name || "anonymous"
))
}});

define({id: "d435cbb2", inputs: ["Generators","addEventListener","removeEventListener"], outputs: ["pointer"], body: (Generators,addEventListener,removeEventListener) => {
const pointer = Generators.observe((change) => {
  const pointermoved = (event) => change([event.clientX, event.clientY]);
  addEventListener("pointermove", pointermoved);
  change([0, 0]);
  return () => removeEventListener("pointermove", pointermoved);
});
return {pointer};
}});

define({id: "458bc875", inputs: ["pointer","display"], body: async (pointer,display) => {
display(await(
pointer.map(Math.round) // try moving your mouse
))
}});

define({id: "33f44e19", outputs: ["j"], body: () => {
const j = (async function* () {
  for (let j = 0; true; ++j) {
    yield j;
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }
})();
return {j};
}});

define({id: "cee00b08", inputs: ["j","display"], body: async (j,display) => {
display(await(
j
))
}});

define({id: "aeef4542", outputs: ["i"], body: () => {
const i = (function* () {
  for (let i = 0; true; ++i) {
    yield i;
  }
})();
return {i};
}});

define({id: "50c393f1", inputs: ["i","display"], body: async (i,display) => {
display(await(
i
))
}});

define({id: "9c3134a5", inputs: ["svg","i","display"], body: async (svg,i,display) => {
display(await(
svg.fragment`<svg width="640" height="32">
  <rect fill="#4269d0" width="32" height="32" x=${(i % (640 + 32)) - 32}></rect>
</svg>`
))
}});

define({id: "9d2288dd", inputs: ["invalidation","Generators"], outputs: ["socket","messages"], body: (invalidation,Generators) => {
const socket = new WebSocket("wss://ws.eodhistoricaldata.com/ws/crypto?api_token=demo");
invalidation.then(() => socket.close());
socket.addEventListener("open", () => socket.send(JSON.stringify({action: "subscribe", symbols: "BTC-USD"})));
const messages = Generators.observe((change) => {
  const messages = [];
  const duration = messages.duration = 60_000;
  const messaged = (event) => {
    const m = JSON.parse(event.data);
    const t = m.t;
    if (t == null) return;
    while ((t - messages[0]?.t) > duration) messages.shift();
    messages.push(m);
    change(messages);
  };
  socket.addEventListener("message", messaged);
  return () => socket.removeEventListener("message", messaged);
});
return {socket,messages};
}});

define({id: "a1f68ccb", inputs: ["Plot","now","messages","display"], body: async (Plot,now,messages,display) => {
display(await(
Plot.plot({
  marginLeft: 50,
  x: {type: "time", domain: [now - messages.duration, now]},
  y: {type: "linear", label: "price", inset: 10},
  marks: [Plot.lineY(messages, {x: "t", y: "p", curve: "step", clip: true})]
})
))
}});

define({id: "292d7c70", inputs: ["view","Inputs"], outputs: ["team"], body: (view,Inputs) => {
const team = view(Inputs.radio(["Metropolis Meteors", "Rockford Peaches", "Bears"], {label: "Favorite team:", value: "Metropolis Meteors"}));
return {team};
}});

define({id: "ca8b22d0", mode: "inline", inputs: ["team","display"], body: async (team,display) => {
display(await(
team
))
}});

define({id: "3b1ef20c", inputs: ["view","html"], outputs: ["n"], body: (view,html) => {
const n = view(html`<input type=range step=1 min=1 max=15>`);
return {n};
}});

define({id: "6aed0d9e", inputs: ["n","display"], body: async (n,display) => {
display(await(
n // Try dragging the slider above
))
}});

define({id: "842a9cf5", inputs: ["view","Plot","penguins"], outputs: ["penguin"], body: (view,Plot,penguins) => {
const penguin = view(Plot.dot(penguins, {x: "culmen_length_mm", y: "flipper_length_mm", tip: true}).plot());
return {penguin};
}});

define({id: "200b117e", inputs: ["penguin","display"], body: async (penguin,display) => {
display(await(
penguin
))
}});

define({id: "2d905154", inputs: ["html","Generators"], outputs: ["subjectInput","subject"], body: (html,Generators) => {
const subjectInput = html`<input type="text" placeholder="anonymous">`;
const subject = Generators.input(subjectInput);
return {subjectInput,subject};
}});

define({id: "4bfa21db", mode: "inline", inputs: ["subjectInput","display"], body: async (subjectInput,display) => {
display(await(
subjectInput
))
}});

define({id: "c5d5cd43", mode: "inline", inputs: ["subject","display"], body: async (subject,display) => {
display(await(
subject || "anonymous"
))
}});

define({id: "748149cf", outputs: ["Mutable"], body: async () => {
const {Mutable} = await import("./_observablehq/stdlib.js");

return {Mutable};
}});

define({id: "a747e3d6", inputs: ["Mutable"], outputs: ["count","increment","reset"], body: (Mutable) => {
const count = Mutable(0);
const increment = () => ++count.value;
const reset = () => count.value = 0;
return {count,increment,reset};
}});

define({id: "136edb6c", inputs: ["Inputs","increment","reset","display"], body: async (Inputs,increment,reset,display) => {
display(await(
Inputs.button([["Increment", increment], ["Reset", reset]])
))
}});

define({id: "e326cce4", mode: "inline", inputs: ["html","count","display"], body: async (html,count,display) => {
display(await(
html`<span class="flash">${count}</span>`
))
}});

define({id: "a60ef2a6", inputs: ["view","Inputs"], outputs: ["clicks","colors","duration"], body: (view,Inputs) => {
const clicks = view(Inputs.button("Click", {label: "Run cell"}));
const colors = ["#4269d0", "#efb118", "#ff725c", "#6cc5b0"];
const duration = 2000;
return {clicks,colors,duration};
}});

define({id: "2e59e9a8", inputs: ["canvas1","colors","clicks","duration","invalidation"], outputs: ["context1","color","start","frame"], body: (canvas1,colors,clicks,duration,invalidation) => {
const context1 = canvas1.getContext("2d");
const color = colors[clicks % 4]; // cycle through colors on click
const start = performance.now(); // when the animation started

let frame = requestAnimationFrame(function tick(now) {
  const t = Math.min(1, (now - start) / duration);
  context1.fillStyle = color;
  context1.fillRect(0, 0, t * canvas1.width, canvas1.height);
  if (t < 1) frame = requestAnimationFrame(tick);
});

invalidation.then(() => cancelAnimationFrame(frame));
return {context1,color,start,frame};
}});

define({id: "745c5597", inputs: ["visibility","canvas2","duration"], outputs: ["context2","start","frame"], body: async (visibility,canvas2,duration) => {
await visibility(); // wait until this node is visible

const context2 = canvas2.getContext("2d");
const start = performance.now();

let frame = requestAnimationFrame(function tick(now) {
  const t = Math.min(1, (now - start) / duration);
  context2.fillStyle = "#a463f2";
  context2.fillRect(0, 0, t * canvas2.width, canvas2.height);
  if (t < 1) frame = requestAnimationFrame(tick);
});
return {context2,start,frame};
}});

</script>
<input id="observablehq-sidebar-toggle" type="checkbox" title="Toggle sidebar">
<label id="observablehq-sidebar-backdrop" for="observablehq-sidebar-toggle"></label>
<nav id="observablehq-sidebar">
  <ol>
    <label id="observablehq-sidebar-close" for="observablehq-sidebar-toggle"></label>
    <li class="observablehq-link"><a href="./">Observable Framework</a></li>
  </ol>
  <div id="observablehq-search"><input type="search" placeholder="Search"></div>
  <div id="observablehq-search-results"></div>
  <script>{const o=document.querySelector("#observablehq-search");o.setAttribute("data-shortcut",`${/Mac|iPhone/.test(navigator.platform)?"\u2318":"Alt-"}K`);const t=o.querySelector("input"),r=()=>import("./_observablehq/search.js");t.addEventListener("focus",r,{once:!0}),t.addEventListener("keydown",r,{once:!0});const c=document.querySelector("#observablehq-sidebar-toggle");addEventListener("keydown",e=>{(e.code==="KeyK"&&e.metaKey&&!e.altKey&&!e.ctrlKey||e.key==="/"&&!e.metaKey&&!e.altKey&&!e.ctrlKey&&e.target===document.body)&&(c.checked?t.focus():(c.click(),t.focus(),c.click()),t.select(),e.preventDefault())});}</script>
  <ol>
    <li class="observablehq-link"><a href="./what-is-framework">What is Framework?</a></li>
    <li class="observablehq-link"><a href="./getting-started">Getting started</a></li>
    <li class="observablehq-link"><a href="./project-structure">Project structure</a></li>
    <li class="observablehq-link"><a href="./markdown">Markdown</a></li>
    <li class="observablehq-link"><a href="./javascript">JavaScript</a></li>
    <li class="observablehq-link observablehq-link-active"><a href="./reactivity">Reactivity</a></li>
    <li class="observablehq-link"><a href="./jsx">JSX</a></li>
    <li class="observablehq-link"><a href="./imports">Imports</a></li>
    <li class="observablehq-link"><a href="./loaders">Data loaders</a></li>
    <li class="observablehq-link"><a href="./files">Files</a></li>
    <li class="observablehq-link"><a href="./sql">SQL</a></li>
    <li class="observablehq-link"><a href="./themes">Themes</a></li>
    <li class="observablehq-link"><a href="./config">Configuration</a></li>
    <li class="observablehq-link"><a href="./deploying">Deploying</a></li>
    <li class="observablehq-link"><a href="https://github.com/observablehq/framework/tree/main/examples" target="_blank"><span>Examples</span></a></li>
  </ol>
  <details>
    <summary>Inputs</summary>
    <ol>
    <li class="observablehq-link"><a href="./inputs/button">Button</a></li>
    <li class="observablehq-link"><a href="./inputs/checkbox">Checkbox</a></li>
    <li class="observablehq-link"><a href="./inputs/color">Color</a></li>
    <li class="observablehq-link"><a href="./inputs/date">Date</a></li>
    <li class="observablehq-link"><a href="./inputs/file">File</a></li>
    <li class="observablehq-link"><a href="./inputs/form">Form</a></li>
    <li class="observablehq-link"><a href="./inputs/radio">Radio</a></li>
    <li class="observablehq-link"><a href="./inputs/range">Range</a></li>
    <li class="observablehq-link"><a href="./inputs/search">Search</a></li>
    <li class="observablehq-link"><a href="./inputs/select">Select</a></li>
    <li class="observablehq-link"><a href="./inputs/table">Table</a></li>
    <li class="observablehq-link"><a href="./inputs/text">Text</a></li>
    <li class="observablehq-link"><a href="./inputs/textarea">Textarea</a></li>
    <li class="observablehq-link"><a href="./inputs/toggle">Toggle</a></li>
    </ol>
  </details>
  <details>
    <summary>Libraries</summary>
    <ol>
    <li class="observablehq-link"><a href="./lib/arrow">Apache Arrow</a></li>
    <li class="observablehq-link"><a href="./lib/arquero">Arquero</a></li>
    <li class="observablehq-link"><a href="./lib/csv">CSV</a></li>
    <li class="observablehq-link"><a href="./lib/d3">D3</a></li>
    <li class="observablehq-link"><a href="./lib/deckgl">Deck.gl</a></li>
    <li class="observablehq-link"><a href="./lib/dot">DOT (Graphviz)</a></li>
    <li class="observablehq-link"><a href="./lib/duckdb">DuckDB</a></li>
    <li class="observablehq-link"><a href="./lib/htl">Hypertext Literal</a></li>
    <li class="observablehq-link"><a href="./lib/leaflet">Leaflet</a></li>
    <li class="observablehq-link"><a href="./lib/lodash">Lodash</a></li>
    <li class="observablehq-link"><a href="./lib/mapbox-gl">Mapbox GL JS</a></li>
    <li class="observablehq-link"><a href="./lib/mermaid">Mermaid</a></li>
    <li class="observablehq-link"><a href="./lib/xlsx">Microsoft Excel (XLSX)</a></li>
    <li class="observablehq-link"><a href="./lib/mosaic">Mosaic vgplot</a></li>
    <li class="observablehq-link"><a href="./lib/generators">Observable Generators</a></li>
    <li class="observablehq-link"><a href="./lib/inputs">Observable Inputs</a></li>
    <li class="observablehq-link"><a href="./lib/plot">Observable Plot</a></li>
    <li class="observablehq-link"><a href="./lib/shapefile">Shapefile</a></li>
    <li class="observablehq-link"><a href="./lib/sqlite">SQLite</a></li>
    <li class="observablehq-link"><a href="./lib/tex">TeX</a></li>
    <li class="observablehq-link"><a href="./lib/topojson">TopoJSON</a></li>
    <li class="observablehq-link"><a href="./lib/vega-lite">Vega-Lite</a></li>
    <li class="observablehq-link"><a href="./lib/zip">ZIP</a></li>
    </ol>
  </details>
  <ol>
    <li class="observablehq-link"><a href="./contributing">Contributing</a></li>
  </ol>
</nav>
<script>{Object.assign(document.createElement("a"),{href:""}).password&&location.replace(location.href);const e=document.querySelector("#observablehq-sidebar"),t=document.querySelector("#observablehq-sidebar-toggle"),r=sessionStorage.getItem("observablehq-sidebar");r?t.checked=r==="true":t.indeterminate=!0;for(const o of document.querySelectorAll("#observablehq-sidebar summary")){const s=o.parentElement;switch(sessionStorage.getItem(`observablehq-sidebar:${o.textContent}`)){case"true":s.open=!0;break;case"false":s.classList.contains("observablehq-section-active")||(s.open=!1);break}}addEventListener("beforeunload",()=>sessionStorage.setItem("observablehq-sidebar-scrolly",`${e.scrollTop}`));const a=sessionStorage.getItem("observablehq-sidebar-scrolly");a!=null&&(e.style.cssText="overflow: hidden;",e.scrollTop=+a,e.style.cssText="");}</script>
<aside id="observablehq-toc" data-selector="h1:not(:first-of-type)[id], h2:first-child[id], :not(h1) + h2[id]">
<nav>
<div>Contents</div>
<ol>
<li class="observablehq-secondary-link"><a href="#top-level-variables">Top-level variables</a></li>
<li class="observablehq-secondary-link"><a href="#promises">Promises</a></li>
<li class="observablehq-secondary-link"><a href="#generators">Generators</a></li>
<li class="observablehq-secondary-link"><a href="#inputs">Inputs</a></li>
<li class="observablehq-secondary-link"><a href="#mutables">Mutables</a></li>
<li class="observablehq-secondary-link"><a href="#invalidation">Invalidation</a></li>
<li class="observablehq-secondary-link"><a href="#visibility">Visibility</a></li>
</ol>
</nav>
</aside>
<div id="observablehq-center">
<header id="observablehq-header">
<div style="display: flex; align-items: center; gap: 0.5rem; height: 2.2rem; margin: -1.5rem -2rem 2rem -2rem; padding: 0.5rem 2rem; border-bottom: solid 1px var(--theme-foreground-faintest); font: 500 16px var(--sans-serif);">
  <a href="https://observablehq.com/" target="_self" rel="" style="display: flex; align-items: center;">
    <svg width="22" height="22" viewBox="0 0 21.92930030822754 22.68549919128418" fill="currentColor">
      <path d="M10.9646 18.9046C9.95224 18.9046 9.07507 18.6853 8.33313 18.2467C7.59386 17.8098 7.0028 17.1909 6.62722 16.4604C6.22789 15.7003 5.93558 14.8965 5.75735 14.0684C5.56825 13.1704 5.47613 12.2574 5.48232 11.3427C5.48232 10.6185 5.52984 9.92616 5.62578 9.26408C5.7208 8.60284 5.89715 7.93067 6.15391 7.24843C6.41066 6.56618 6.74143 5.97468 7.14438 5.47308C7.56389 4.9592 8.1063 4.54092 8.72969 4.25059C9.38391 3.93719 10.1277 3.78091 10.9646 3.78091C11.977 3.78091 12.8542 4.00021 13.5962 4.43879C14.3354 4.87564 14.9265 5.49454 15.3021 6.22506C15.6986 6.97704 15.9883 7.7744 16.1719 8.61712C16.3547 9.459 16.447 10.3681 16.447 11.3427C16.447 12.067 16.3995 12.7593 16.3035 13.4214C16.2013 14.1088 16.0206 14.7844 15.7644 15.437C15.4994 16.1193 15.1705 16.7108 14.7739 17.2124C14.3774 17.714 13.8529 18.1215 13.1996 18.4349C12.5463 18.7483 11.8016 18.9046 10.9646 18.9046ZM12.8999 13.3447C13.4242 12.8211 13.7159 12.0966 13.7058 11.3427C13.7058 10.5639 13.4436 9.89654 12.92 9.34074C12.3955 8.78495 11.7441 8.50705 10.9646 8.50705C10.1852 8.50705 9.53376 8.78495 9.00928 9.34074C8.49569 9.87018 8.21207 10.5928 8.22348 11.3427C8.22348 12.1216 8.48572 12.7889 9.00928 13.3447C9.53376 13.9005 10.1852 14.1784 10.9646 14.1784C11.7441 14.1784 12.3891 13.9005 12.8999 13.3447ZM10.9646 22.6855C17.0199 22.6855 21.9293 17.6068 21.9293 11.3427C21.9293 5.07871 17.0199 0 10.9646 0C4.90942 0 0 5.07871 0 11.3427C0 17.6068 4.90942 22.6855 10.9646 22.6855Z"></path>
    </svg>
  </a>
  <div style="display: flex; flex-grow: 1; justify-content: space-between; align-items: baseline;">
    <a href="./">
      <span class="hide-if-small">Observable</span> Framework
    </a>
    <span style="display: flex; align-items: baseline; gap: 1rem; font-size: 14px;">
      <a target="_blank" title="1.9.0 release notes" href="https://github.com/observablehq/framework/releases" rel="noopener noreferrer"><span>1.9.0</span></a>
      <a target="_blank" data-decoration="★" title="2,121 GitHub stars" href="https://github.com/observablehq/framework" rel="noopener noreferrer"><span>GitHub️ 2.1k</span></a>
    </span>
  </div>
</div>
</header>
<main id="observablehq-main" class="observablehq">
<h1 id="reactivity" tabindex="-1"><a class="observablehq-header-anchor" href="#reactivity">Reactivity</a></h1>
<p>Framework runs like a spreadsheet: code re-runs automatically when referenced variables change. This brings:</p>
<ul>
<li>Easier interactivity because state is automatically kept in sync</li>
<li>Easier asynchronous programming via implicit await of promises</li>
<li>Better performance with incremental re-rendering</li>
<li>Greater flexibility by writing code and prose in any order</li>
</ul>
<p>Reactivity is especially helpful for data apps because these apps tend to have complex state. (See Observable’s founding essay, <a href="https://medium.com/@mbostock/a-better-way-to-code-2b1d2876a3a0" target="_blank" rel="noopener noreferrer"><em>A Better Way to Code</em></a>.) For example, you might want to update a chart when a user interacts with a menu or composes a query. Or you might simply want to load several datasets in parallel. Reactivity means you don’t have to manage complex state changes — you can code declaratively as if state were static and immutable, letting the runtime manage state for you.</p>
<p>Unlike reactive libraries, Framework’s reactivity is implemented at the language layer as part of the JavaScript runtime: there’s no new API or syntax to learn. It’s vanilla JavaScript, but the code runs automatically. Code blocks in Markdown run in topological order determined by top-level variable references (a.k.a. <em>dataflow</em>), rather than in top-down document order. For example, here we reference variables <code>x</code> and <code>y</code> even though they are defined in a code block farther down the page:</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:bd100eeb:--></div>
<pre data-language="js"><code class="language-js">x + y
</code></pre>
<p>When code (such as <code>x + y</code>) references top-level variables (such as <code>x</code> and <code>y</code>) defined by other code, the <em>referencing</em> code automatically runs <em>after</em> the <em>defining</em> code. Since code runs independent of its order on the page, you can arrange code however you like.</p>
<p>Reactivity also allows incremental evaluation of code when values change: only the code blocks that are downstream of changed variables run. This makes interaction and animation more performant because you’re not re-rendering the entire page when state changes.</p>
<p>To be precise, Framework’s reactivity manifests as:</p>
<ul>
<li><a href="#promises">Promises</a> are implicitly awaited across code blocks</li>
<li><a href="#generators">Generators</a> are implicitly iterated across code blocks</li>
<li>Editing code (or files) triggers reactive updates during preview</li>
<li>The <a href="#invalidation"><code>invalidation</code> promise</a> allows clean-up</li>
</ul>
<p>We’ll cover each of these below.</p>
<h2 id="top-level-variables" tabindex="-1"><a class="observablehq-header-anchor" href="#top-level-variables">Top-level variables</a></h2>
<div class="tip">Only pages can declare top-level reactive variables. Components can’t define their own reactive state, but you can pass values to them.</div>
<p>A top-level variable declared in a JavaScript fenced code block can be referenced in another code block or inline expression on the same page. So if you say:</p>
<div class="observablehq observablehq--block"><!--:724b726b:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span>, y = <span class="hljs-number">2</span>;
</code></pre>
<p>Then you can reference <code>x</code> and <code>y</code> elsewhere on the page (with values <observablehq-loading></observablehq-loading><!--:2d711642:--> and <observablehq-loading></observablehq-loading><!--:a1fce436:-->, respectively); top-level variable declarations are effectively <a href="https://developer.mozilla.org/en-US/docs/Glossary/Hoisting" target="_blank" rel="noopener noreferrer">hoisted</a>.</p>
<p>To prevent variables from being visible outside the current block, make them local with a block statement (curly braces):</p>
<div class="observablehq observablehq--block"><!--:5ac3981e:--></div>
<pre data-language="js"><code class="language-js">{
  <span class="hljs-keyword">const</span> z = <span class="hljs-number">3</span>;
}
</code></pre>
<p>If multiple blocks define top-level variables with the same name, these blocks will still run, but any references to duplicated variables in other blocks will throw a duplicate definition error because the definition is ambiguous.</p>
<h2 id="promises" tabindex="-1"><a class="observablehq-header-anchor" href="#promises">Promises</a></h2>
<div class="tip">See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises" target="_blank" rel="noopener noreferrer">MDN’s <i>Using promises</i></a> for an introduction to promises.</div>
<p>A <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer">promise</a> represents the result of an asynchronous operation: some data loaded from a file, say, or a module imported dynamically, or the end of an animation, or some text input from the user.</p>
<p>In Framework, when one code block refers to a promise defined in another code block, the referencing code block implicitly awaits the promise. This means promises are often invisible — you don’t have to worry whether something is a promise or whether it’s resolved.</p>
<div class="note">Implicit <code>await</code> only applies <i>across</i> code blocks, not <i>within</i> a code block. Within a code block, a promise is just a promise.</div>
<p>For example, below <code>FileAttachment.json</code> returns a promise, and so the value of <code>volcano</code> inside the code block is a promise.</p>
<div class="observablehq observablehq--block"><!--:8a489158:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> volcano = <span class="hljs-title class_">FileAttachment</span>(<span class="hljs-string">"volcano.json"</span>).<span class="hljs-title function_">json</span>();
</code></pre>
<p>And yet if we reference <code>volcano</code> in another code block or inline expression, we don’t need to <code>await</code>. The <code>await</code> is implicit; the code block automatically waits for the <code>volcano</code> promise to resolve before running.</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:d1a89d65:--></div>
<pre data-language="js"><code class="language-js">volcano
</code></pre>
<p>The volcano dataset has <observablehq-loading></observablehq-loading><!--:4b333a16:--> values.</p>
<pre data-language="md"><code class="language-md">The volcano dataset has ${volcano.values.length.toLocaleString("en-US")} values.
</code></pre>
<p>This pattern is especially useful for loading multiple files. The files are loaded in parallel, and referencing code blocks only wait for the files they need. This is faster than loading files sequentially with <code>await</code>, and simpler than <code>Promise.all</code>.</p>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> a = <span class="hljs-title class_">FileAttachment</span>(<span class="hljs-string">"a.csv"</span>).<span class="hljs-title function_">csv</span>({<span class="hljs-attr">typed</span>: <span class="hljs-literal">true</span>});
<span class="hljs-keyword">const</span> b = <span class="hljs-title class_">FileAttachment</span>(<span class="hljs-string">"b.csv"</span>).<span class="hljs-title function_">csv</span>({<span class="hljs-attr">typed</span>: <span class="hljs-literal">true</span>});
<span class="hljs-keyword">const</span> c = <span class="hljs-title class_">FileAttachment</span>(<span class="hljs-string">"c.csv"</span>).<span class="hljs-title function_">csv</span>({<span class="hljs-attr">typed</span>: <span class="hljs-literal">true</span>});
</code></pre>
<p>Implicit await causes the entire code block to wait, not just expressions that reference promises. This distinction is usually invisible, but you might notice if you have a code block that references both “slow” and “fast” promises: the code block waits for all promises to resolve, and thus is gated by the slowest promise. Below, “fast” and “slow” are printed at the same time.</p>
<div class="observablehq observablehq--block"><!--:6a8a2621:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> fast = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"fast"</span>), <span class="hljs-number">500</span>));
<span class="hljs-keyword">const</span> slow = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-string">"slow"</span>), <span class="hljs-number">5000</span>));
</code></pre>
<div class="observablehq observablehq--block"><!--:6c194ecc:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-title function_">display</span>(fast);
<span class="hljs-title function_">display</span>(slow);
</code></pre>
<p>Implicit await means waiting for the defining code block to fulfill, not only the referenced promises. Below, even though <code>one</code> and <code>two</code> are defined synchronously, the referencing code block must wait 5 seconds for the defining block to resolve. This allows a defining code block to initialize state asynchronously while preventing referencing code blocks from seeing partially-initialized state.</p>
<div class="observablehq observablehq--block"><!--:c233565e:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> one = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> two = <span class="hljs-number">2</span>;
<span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">5000</span>));
</code></pre>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:74aff20d:--></div>
<pre data-language="js"><code class="language-js">one + two <span class="hljs-comment">// waits 5 seconds!</span>
</code></pre>
<p>Implicit await means that you can’t handle errors across code blocks: if a promise rejects, the reference code block simply doesn’t run, so it has no way of catching errors. That said, you can handle errors <em>within</em> a code block. For example, you can specify fallback data for a file that fails to load.</p>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> volcano = <span class="hljs-title class_">FileAttachment</span>(<span class="hljs-string">"volcano.json"</span>)
  .<span class="hljs-title function_">json</span>()
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> ({<span class="hljs-attr">width</span>: <span class="hljs-number">87</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">61</span>, <span class="hljs-attr">values</span>: []}));
</code></pre>
<h2 id="generators" tabindex="-1"><a class="observablehq-header-anchor" href="#generators">Generators</a></h2>
<p>Values that change over time — such as interactive inputs, animation parameters, or streaming data — can be represented in Framework as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator" target="_blank" rel="noopener noreferrer">async generators</a>. When a top-level generator is declared, code in other blocks sees the generator’s latest yielded value and runs each time the generator yields a new value.</p>
<div class="note">As with implicit await and promises, implicit iteration of generators only applies <i>across</i> code blocks, not <i>within</i> a code block.</div>
<p>As an example, here’s an HTML input element. By passing it to <a href="../lib/generators#input(element)"><code>Generators.input</code></a>, we can define a generator that yields the input’s value each time it changes.</p>
<input id="nameInput">
<pre data-language="html"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"nameInput"</span>&gt;</span>
</code></pre>
<div class="observablehq observablehq--block"><!--:42cc9a81:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> name = <span class="hljs-title class_">Generators</span>.<span class="hljs-title function_">input</span>(nameInput);
</code></pre>
<p>Now when we reference <code>name</code> in another code block or inline expression, it refers to the current value of the input element, and the code block runs each time the input changes. Try typing into the input field above.</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:f80b1fa8:--></div>
<pre data-language="js"><code class="language-js">name
</code></pre>
<p>Hello, <observablehq-loading></observablehq-loading><!--:b9872a62:-->!</p>
<pre data-language="md"><code class="language-md">Hello, ${name || "anonymous"}!
</code></pre>
<p>The above example uses <code>Generators.input</code>, which is a helper method that takes an input element and returns a corresponding value generator. More often, you’ll use the <code>view</code> function to define an <a href="#inputs">input</a>; we’ll cover that below, but first we’ll take a deeper look at how generators work.</p>
<p>The <code>Generators.observe</code> helper is a more general way to create a generator that “pushes” or “emits” events asynchronously. This helper takes an initializer function and passes it a <code>notify</code> callback which you call with each new value; the initializer can also return a disposal function to cleanup when the generator is terminated. The resulting generator yields each value you pass to <code>notify</code>. To implement the <code>name</code> generator above using <code>Generators.observe</code>:</p>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> name = <span class="hljs-title class_">Generators</span>.<span class="hljs-title function_">observe</span>(<span class="hljs-function">(<span class="hljs-params">notify</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">inputted</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title function_">notify</span>(nameInput.<span class="hljs-property">value</span>);
  <span class="hljs-title function_">inputted</span>();
  nameInput.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"input"</span>, inputted);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> nameInput.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">"input"</span>, inputted);
});
</code></pre>
<p>As another example, here is using <code>Generators.observe</code> to expose the current pointer coordinates:</p>
<div class="observablehq observablehq--block"><!--:d435cbb2:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> pointer = <span class="hljs-title class_">Generators</span>.<span class="hljs-title function_">observe</span>(<span class="hljs-function">(<span class="hljs-params">change</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">pointermoved</span> = (<span class="hljs-params">event</span>) =&gt; <span class="hljs-title function_">change</span>([event.<span class="hljs-property">clientX</span>, event.<span class="hljs-property">clientY</span>]);
  <span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"pointermove"</span>, pointermoved);
  <span class="hljs-title function_">change</span>([<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">"pointermove"</span>, pointermoved);
});
</code></pre>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:458bc875:--></div>
<pre data-language="js"><code class="language-js">pointer.<span class="hljs-title function_">map</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-property">round</span>) <span class="hljs-comment">// try moving your mouse</span>
</code></pre>
<p>And here’s a generator <code>j</code> that increments once a second, defined directly by an immediately-invoked async generator function.</p>
<div class="observablehq observablehq--block"><!--:33f44e19:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> j = (<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* () {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; <span class="hljs-literal">true</span>; ++j) {
    <span class="hljs-keyword">yield</span> j;
    <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>));
  }
})();
</code></pre>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:cee00b08:--></div>
<pre data-language="js"><code class="language-js">j
</code></pre>
<p>If a generator does not explicitly <code>await</code>, it will yield once every <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" target="_blank" rel="noopener noreferrer">animation frame</a>, typically 60 times per second. Generators also automatically pause when the page is put in a background tab.</p>
<div class="observablehq observablehq--block"><!--:aeef4542:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> i = (<span class="hljs-keyword">function</span>* () {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; <span class="hljs-literal">true</span>; ++i) {
    <span class="hljs-keyword">yield</span> i;
  }
})();
</code></pre>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:50c393f1:--></div>
<pre data-language="js"><code class="language-js">i
</code></pre>
<p>As you might imagine, you can use such a generator to drive an animation. A generator is typically easier than a <code>requestAnimationFrame</code> loop because the animation is declarative — the code runs automatically whenever <code>i</code> changes — and because you don’t have to handle <a href="#invalidation">invalidation</a> to terminate the loop.</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:9c3134a5:--></div>
<pre data-language="svg"><code class="language-svg"><span class="hljs-tag">&lt;<span class="hljs-name">svg</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"640"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"32"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">rect</span> <span class="hljs-attr">fill</span>=<span class="hljs-string">"#4269d0"</span> <span class="hljs-attr">width</span>=<span class="hljs-string">"32"</span> <span class="hljs-attr">height</span>=<span class="hljs-string">"32"</span> <span class="hljs-attr">x</span>=<span class="hljs-string">${(i</span> % (<span class="hljs-attr">640</span> + <span class="hljs-attr">32</span>)) <span class="hljs-attr">-</span> <span class="hljs-attr">32</span>}&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">rect</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span>
</code></pre>
<p>You can also use a generator to stream live data. Here is a WebSocket that listens for the current price of Bitcoin, keeping the last minute of data in memory.</p>
<div class="observablehq observablehq--block"><!--:9d2288dd:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">"wss://ws.eodhistoricaldata.com/ws/crypto?api_token=demo"</span>);
invalidation.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> socket.<span class="hljs-title function_">close</span>());
socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"open"</span>, <span class="hljs-function">() =&gt;</span> socket.<span class="hljs-title function_">send</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>({<span class="hljs-attr">action</span>: <span class="hljs-string">"subscribe"</span>, <span class="hljs-attr">symbols</span>: <span class="hljs-string">"BTC-USD"</span>})));
<span class="hljs-keyword">const</span> messages = <span class="hljs-title class_">Generators</span>.<span class="hljs-title function_">observe</span>(<span class="hljs-function">(<span class="hljs-params">change</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> messages = [];
  <span class="hljs-keyword">const</span> duration = messages.<span class="hljs-property">duration</span> = <span class="hljs-number">60_000</span>;
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">messaged</span> = (<span class="hljs-params">event</span>) =&gt; {
    <span class="hljs-keyword">const</span> m = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(event.<span class="hljs-property">data</span>);
    <span class="hljs-keyword">const</span> t = m.<span class="hljs-property">t</span>;
    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
    <span class="hljs-keyword">while</span> ((t - messages[<span class="hljs-number">0</span>]?.<span class="hljs-property">t</span>) &gt; duration) messages.<span class="hljs-title function_">shift</span>();
    messages.<span class="hljs-title function_">push</span>(m);
    <span class="hljs-title function_">change</span>(messages);
  };
  socket.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"message"</span>, messaged);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> socket.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">"message"</span>, messaged);
});
</code></pre>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:a1f68ccb:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-title class_">Plot</span>.<span class="hljs-title function_">plot</span>({
  <span class="hljs-attr">marginLeft</span>: <span class="hljs-number">50</span>,
  <span class="hljs-attr">x</span>: {<span class="hljs-attr">type</span>: <span class="hljs-string">"time"</span>, <span class="hljs-attr">domain</span>: [now - messages.<span class="hljs-property">duration</span>, now]},
  <span class="hljs-attr">y</span>: {<span class="hljs-attr">type</span>: <span class="hljs-string">"linear"</span>, <span class="hljs-attr">label</span>: <span class="hljs-string">"price"</span>, <span class="hljs-attr">inset</span>: <span class="hljs-number">10</span>},
  <span class="hljs-attr">marks</span>: [<span class="hljs-title class_">Plot</span>.<span class="hljs-title function_">lineY</span>(messages, {<span class="hljs-attr">x</span>: <span class="hljs-string">"t"</span>, <span class="hljs-attr">y</span>: <span class="hljs-string">"p"</span>, <span class="hljs-attr">curve</span>: <span class="hljs-string">"step"</span>, <span class="hljs-attr">clip</span>: <span class="hljs-literal">true</span>})]
})
</code></pre>
<h2 id="inputs" tabindex="-1"><a class="observablehq-header-anchor" href="#inputs">Inputs</a></h2>
<p>Inputs are graphical user interface elements such as dropdowns, radios, sliders, and text boxes that accept data from a user and enable interaction via reactivity. They can also be custom elements that you design, such as charts that support interactive selection via pointing or brushing.</p>
<p>Inputs might prompt a viewer to:</p>
<ul>
<li>Filter a table of users by typing in a name</li>
<li>Select a URL from a dropdown to view traffic to a specific page</li>
<li>Choose a date range to explore data within a period of interest</li>
</ul>
<p>Inputs are typically displayed using the built-in <code>view</code> function, which <a href="../javascript#explicit-display">displays</a> the given element and returns a corresponding value generator (<code>Generators.input</code>) to expose the input’s value to the page. For example, the radio input below prompts for your favorite team:</p>
<div class="observablehq observablehq--block"><!--:292d7c70:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> team = <span class="hljs-title function_">view</span>(<span class="hljs-title class_">Inputs</span>.<span class="hljs-title function_">radio</span>([<span class="hljs-string">"Metropolis Meteors"</span>, <span class="hljs-string">"Rockford Peaches"</span>, <span class="hljs-string">"Bears"</span>], {<span class="hljs-attr">label</span>: <span class="hljs-string">"Favorite team:"</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">"Metropolis Meteors"</span>}));
</code></pre>
<p>Code blocks that reference <code>team</code> re-run automatically when the user interacts with the radio input. Try selecting a different team.</p>
<p>My favorite baseball team is the <observablehq-loading></observablehq-loading><!--:ca8b22d0:-->!</p>
<pre data-language="md"><code class="language-md">My favorite baseball team is the ${team}!
</code></pre>
<p>The above example uses <code>Inputs.radio</code>, which is provided by <a href="./lib/inputs">Observable Inputs</a>. You can also implement custom inputs using arbitrary HTML. For example, here is a <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range" target="_blank" rel="noopener noreferrer">range input</a> that lets you choose an integer between 1 and 15 (inclusive):</p>
<div class="observablehq observablehq--block"><!--:3b1ef20c:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> n = <span class="hljs-title function_">view</span>(html`<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">range</span> <span class="hljs-attr">step</span>=<span class="hljs-string">1</span> <span class="hljs-attr">min</span>=<span class="hljs-string">1</span> <span class="hljs-attr">max</span>=<span class="hljs-string">15</span>&gt;</span>`</span>);
</code></pre>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:6aed0d9e:--></div>
<pre data-language="js"><code class="language-js">n <span class="hljs-comment">// Try dragging the slider above</span>
</code></pre>
<div class="tip">To be compatible with <code>view</code>, custom inputs must emit <code>input</code> events when their value changes, and expose their current value as <i>element</i>.value. See <a href="./lib/generators#input(element)"><code>Generators.input</code></a> for more.</div>
<p>To use a chart as an input, you can use Plot’s <a href="https://observablehq.com/plot/interactions/pointer" target="_blank" rel="noopener noreferrer">pointer interaction</a>, say by setting the <strong>tip</strong> option on a mark. In the scatterplot below, the penguin closest to the pointer is exposed as the reactive variable <code>penguin</code>.</p>
<div class="observablehq observablehq--block"><!--:842a9cf5:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> penguin = <span class="hljs-title function_">view</span>(<span class="hljs-title class_">Plot</span>.<span class="hljs-title function_">dot</span>(penguins, {<span class="hljs-attr">x</span>: <span class="hljs-string">"culmen_length_mm"</span>, <span class="hljs-attr">y</span>: <span class="hljs-string">"flipper_length_mm"</span>, <span class="hljs-attr">tip</span>: <span class="hljs-literal">true</span>}).<span class="hljs-title function_">plot</span>());
</code></pre>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:200b117e:--></div>
<pre data-language="js"><code class="language-js">penguin
</code></pre>
<p>In the future, Plot will support more interaction methods, including brushing. Please upvote <a href="https://github.com/observablehq/plot/issues/5" target="_blank" rel="noopener noreferrer">#5</a> if you are interested in this feature.</p>
<p>The <code>view</code> function does two things:</p>
<ol>
<li>it <a href="../javascript#explicit-display">displays</a> the given DOM <em>element</em>, and then</li>
<li>returns a corresponding value generator.</li>
</ol>
<p>The <code>view</code> function uses <a href="../lib/generators#input(element)"><code>Generators.input</code></a> under the hood. As shown above, you can call <code>Generators.input</code> directly, say to declare the input as a top-level variable without immediately displaying it.</p>
<div class="observablehq observablehq--block"><!--:2d905154:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> subjectInput = html`<span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"anonymous"</span>&gt;</span>`</span>;
<span class="hljs-keyword">const</span> subject = <span class="hljs-title class_">Generators</span>.<span class="hljs-title function_">input</span>(subjectInput);
</code></pre>
<p>You can then display the input anywhere you like. And you can reference the input’s value reactively anywhere, too. Below, both are displayed in a card.</p>
<div class="card" style="display: grid; gap: 0.5rem;">
  <div>Enter your name: <observablehq-loading></observablehq-loading><!--:4bfa21db:--></div>
  <div>Hi <b><observablehq-loading></observablehq-loading><!--:c5d5cd43:--></b>!</div>
</div>
<pre data-language="html"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"card"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display: grid; gap: 0.5rem;"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Enter your name: ${subjectInput}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hi <span class="hljs-tag">&lt;<span class="hljs-name">b</span>&gt;</span>${subject || "anonymous"}<span class="hljs-tag">&lt;/<span class="hljs-name">b</span>&gt;</span>!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h2 id="mutables" tabindex="-1"><a class="observablehq-header-anchor" href="#mutables">Mutables</a></h2>
<p>Normally, only the code block that declares a top-level variable can define it or assign to it. You can however use the <code>Mutable</code> function to declare a mutable generator, allowing other code to mutate the generator’s value. This is similar to React’s <code>useState</code> hook.</p>
<p><code>Mutable</code> is available by default in Markdown but you can import&nbsp;it explicitly like so:</p>
<div class="observablehq observablehq--block"><!--:748149cf:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">import</span> {<span class="hljs-title class_">Mutable</span>} <span class="hljs-keyword">from</span> <span class="hljs-string">"npm:@observablehq/stdlib"</span>;
</code></pre>
<p>Then to use it:</p>
<div class="observablehq observablehq--block"><!--:a747e3d6:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> count = <span class="hljs-title class_">Mutable</span>(<span class="hljs-number">0</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; ++count.<span class="hljs-property">value</span>;
<span class="hljs-keyword">const</span> <span class="hljs-title function_">reset</span> = (<span class="hljs-params"></span>) =&gt; count.<span class="hljs-property">value</span> = <span class="hljs-number">0</span>;
</code></pre>
<p>In other code, you can now create buttons to increment and reset the count like so:</p>
<div class="observablehq observablehq--block"><observablehq-loading></observablehq-loading><!--:136edb6c:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-title class_">Inputs</span>.<span class="hljs-title function_">button</span>([[<span class="hljs-string">"Increment"</span>, increment], [<span class="hljs-string">"Reset"</span>, reset]])
</code></pre>
<style type="text/css">
@keyframes flash {
  from { background-color: var(--theme-blue); }
  to { background-color: none; }
}
.flash {
  animation-name: flash;
  animation-duration: 1s;
}
</style>
<p>Count is: <observablehq-loading></observablehq-loading><!--:e326cce4:-->.</p>
<pre data-language="md"><code class="language-md">Count is: ${html<span class="hljs-code">`&lt;span class="flash"&gt;${count}&lt;/span&gt;`</span>}.
</code></pre>
<p>Within the defining code block, <code>count</code> is a generator and <code>count.value</code> can be read and written to as desired; in other code, <code>count</code> is the generator’s current value. Other code that references <code>count</code> will re-run automatically whenever <code>count.value</code> is reassigned —&nbsp;so be careful you don’t cause an infinite loop!</p>
<h2 id="invalidation" tabindex="-1"><a class="observablehq-header-anchor" href="#invalidation">Invalidation</a></h2>
<p>With reactive evaluation, code blocks can run multiple times, say in response to interaction or streaming data. If you need to “clean up” after a code block, say to cancel an animation loop or close a socket, use the <code>invalidation</code> promise to register a disposal hook.</p>
<p>For example, the cell below uses <code>requestAnimationFrame</code> to animate a canvas. The <code>invalidation</code> promise is used to cancel the old animation when a new animation starts. Try quickly clicking the button below.</p>
<div class="observablehq observablehq--block"><!--:a60ef2a6:--></div>
<p><canvas id="canvas1" width="640" height="30" style="max-width: 100%; height: 30px;"></canvas></p>
<div class="observablehq observablehq--block"><!--:2e59e9a8:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">const</span> context1 = canvas1.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">"2d"</span>);
<span class="hljs-keyword">const</span> color = colors[clicks % <span class="hljs-number">4</span>]; <span class="hljs-comment">// cycle through colors on click</span>
<span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>(); <span class="hljs-comment">// when the animation started</span>

<span class="hljs-keyword">let</span> frame = <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">tick</span>(<span class="hljs-params">now</span>) {
  <span class="hljs-keyword">const</span> t = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, (now - start) / duration);
  context1.<span class="hljs-property">fillStyle</span> = color;
  context1.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, t * canvas1.<span class="hljs-property">width</span>, canvas1.<span class="hljs-property">height</span>);
  <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">1</span>) frame = <span class="hljs-title function_">requestAnimationFrame</span>(tick);
});

invalidation.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">cancelAnimationFrame</span>(frame));
</code></pre>
<h2 id="visibility" tabindex="-1"><a class="observablehq-header-anchor" href="#visibility">Visibility</a></h2>
<p>The <code>visibility</code> function returns a promise that resolves when the code block’s display root is visible. This allows you to defer animation or computation until the content scrolls into view. If you missed the animation, try reloading the page and then scrolling down.</p>
<p><canvas id="canvas2" width="640" height="30" style="max-width: 100%; height: 30px;"></canvas></p>
<div class="observablehq observablehq--block"><!--:745c5597:--></div>
<pre data-language="js"><code class="language-js"><span class="hljs-keyword">await</span> <span class="hljs-title function_">visibility</span>(); <span class="hljs-comment">// wait until this node is visible</span>

<span class="hljs-keyword">const</span> context2 = canvas2.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">"2d"</span>);
<span class="hljs-keyword">const</span> start = performance.<span class="hljs-title function_">now</span>();

<span class="hljs-keyword">let</span> frame = <span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">tick</span>(<span class="hljs-params">now</span>) {
  <span class="hljs-keyword">const</span> t = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>, (now - start) / duration);
  context2.<span class="hljs-property">fillStyle</span> = <span class="hljs-string">"#a463f2"</span>;
  context2.<span class="hljs-title function_">fillRect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, t * canvas2.<span class="hljs-property">width</span>, canvas2.<span class="hljs-property">height</span>);
  <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">1</span>) frame = <span class="hljs-title function_">requestAnimationFrame</span>(tick);
});
</code></pre>
</main>
<footer id="observablehq-footer">
<nav><a rel="prev" href="./javascript"><span>JavaScript</span></a><a rel="next" href="./jsx"><span>JSX</span></a></nav>
<div>© 2024 Observable, Inc.</div>
</footer>
</div>
